export module xml.xml_parser;

import xml.xml_processor;

import lexer;
import parser;

// this file has been automatically generated from 'C:/work/wingstall/sngxml/xml/XmlParser.parser' using soulng parser generator spg version 4.0.0

export struct XmlParser
{
    static void Parse(TrivialLexer& lexer, xml::XmlProcessor* processor);
    static parser::Match Document(TrivialLexer& lexer, xml::XmlProcessor* processor);
    static parser::Match Char(TrivialLexer& lexer);
    static parser::Match S(TrivialLexer& lexer);
    static parser::Match NameStartChar(TrivialLexer& lexer);
    static parser::Match NameChar(TrivialLexer& lexer);
    static parser::Match Name(TrivialLexer& lexer);
    static parser::Match Names(TrivialLexer& lexer);
    static parser::Match Nmtoken(TrivialLexer& lexer);
    static parser::Match Nmtokens(TrivialLexer& lexer);
    static parser::Match Prolog(TrivialLexer& lexer, xml::XmlProcessor* processor);
    static parser::Match XMLDecl(TrivialLexer& lexer, xml::XmlProcessor* processor);
    static parser::Match VersionInfo(TrivialLexer& lexer, xml::XmlProcessor* processor);
    static parser::Match VersionNum(TrivialLexer& lexer, xml::XmlProcessor* processor);
    static parser::Match VersionNumDQ(TrivialLexer& lexer, xml::XmlProcessor* processor);
    static parser::Match VersionNumSQ(TrivialLexer& lexer, xml::XmlProcessor* processor);
    static parser::Match VersionNumber(TrivialLexer& lexer, xml::XmlProcessor* processor);
    static parser::Match EncodingDecl(TrivialLexer& lexer, xml::XmlProcessor* processor);
    static parser::Match EncodingName(TrivialLexer& lexer, xml::XmlProcessor* processor);
    static parser::Match EncNameDQ(TrivialLexer& lexer, xml::XmlProcessor* processor);
    static parser::Match EncNameSQ(TrivialLexer& lexer, xml::XmlProcessor* processor);
    static parser::Match EncName(TrivialLexer& lexer, xml::XmlProcessor* processor);
    static parser::Match SDDecl(TrivialLexer& lexer, xml::XmlProcessor* processor);
    static parser::Match DocTypeDecl(TrivialLexer& lexer, xml::XmlProcessor* processor);
    static parser::Match ExternalID(TrivialLexer& lexer);
    static parser::Match SystemLiteral(TrivialLexer& lexer);
    static parser::Match PubidLiteral(TrivialLexer& lexer);
    static parser::Match PubidChar(TrivialLexer& lexer);
    static parser::Match IntSubset(TrivialLexer& lexer, xml::XmlProcessor* processor);
    static parser::Match MarkupDecl(TrivialLexer& lexer, xml::XmlProcessor* processor);
    static parser::Match DeclSep(TrivialLexer& lexer, xml::XmlProcessor* processor);
    static parser::Match ElementDecl(TrivialLexer& lexer, xml::XmlProcessor* processor);
    static parser::Match ContentSpec(TrivialLexer& lexer);
    static parser::Match Children(TrivialLexer& lexer);
    static parser::Match CP(TrivialLexer& lexer);
    static parser::Match Choice(TrivialLexer& lexer);
    static parser::Match Seq(TrivialLexer& lexer);
    static parser::Match Mixed(TrivialLexer& lexer);
    static parser::Match AttlistDecl(TrivialLexer& lexer, xml::XmlProcessor* processor);
    static parser::Match AttDef(TrivialLexer& lexer, xml::XmlProcessor* processor);
    static parser::Match AttType(TrivialLexer& lexer);
    static parser::Match StringType(TrivialLexer& lexer);
    static parser::Match TokenizedType(TrivialLexer& lexer);
    static parser::Match EnumeratedType(TrivialLexer& lexer);
    static parser::Match NotationType(TrivialLexer& lexer);
    static parser::Match Enumeration(TrivialLexer& lexer);
    static parser::Match DefaultDecl(TrivialLexer& lexer, xml::XmlProcessor* processor);
    static parser::Match EntityDecl(TrivialLexer& lexer, xml::XmlProcessor* processor);
    static parser::Match GEDecl(TrivialLexer& lexer, xml::XmlProcessor* processor);
    static parser::Match PEDecl(TrivialLexer& lexer, xml::XmlProcessor* processor);
    static parser::Match EntityDef(TrivialLexer& lexer, xml::XmlProcessor* processor);
    static parser::Match PEDef(TrivialLexer& lexer, xml::XmlProcessor* processor);
    static parser::Match EntityValue(TrivialLexer& lexer, xml::XmlProcessor* processor);
    static parser::Match NDataDecl(TrivialLexer& lexer);
    static parser::Match PEReference(TrivialLexer& lexer, xml::XmlProcessor* processor);
    static parser::Match NotationDecl(TrivialLexer& lexer, xml::XmlProcessor* processor);
    static parser::Match PublicID(TrivialLexer& lexer);
    static parser::Match Element(TrivialLexer& lexer, xml::XmlProcessor* processor);
    static parser::Match ETag(TrivialLexer& lexer, xml::XmlProcessor* processor);
    static parser::Match Content(TrivialLexer& lexer, xml::XmlProcessor* processor);
    static parser::Match CharDataChar(TrivialLexer& lexer);
    static parser::Match CharData(TrivialLexer& lexer, xml::XmlProcessor* processor);
    static parser::Match CDSect(TrivialLexer& lexer, xml::XmlProcessor* processor);
    static parser::Match Attribute(TrivialLexer& lexer, xml::XmlProcessor* processor);
    static parser::Match AttValueDQ(TrivialLexer& lexer, xml::XmlProcessor* processor);
    static parser::Match AttValueSQ(TrivialLexer& lexer, xml::XmlProcessor* processor);
    static parser::Match AttValue(TrivialLexer& lexer, xml::XmlProcessor* processor);
    static parser::Match EntityRef(TrivialLexer& lexer, xml::XmlProcessor* processor);
    static parser::Match DecCodePoint(TrivialLexer& lexer);
    static parser::Match HexCodePoint(TrivialLexer& lexer);
    static parser::Match CharRef(TrivialLexer& lexer, xml::XmlProcessor* processor);
    static parser::Match Reference(TrivialLexer& lexer, xml::XmlProcessor* processor);
    static parser::Match Misc(TrivialLexer& lexer, xml::XmlProcessor* processor);
    static parser::Match Comment(TrivialLexer& lexer, xml::XmlProcessor* processor);
    static parser::Match PI(TrivialLexer& lexer, xml::XmlProcessor* processor);
    static parser::Match PITarget(TrivialLexer& lexer);
    static parser::Match Xml(TrivialLexer& lexer);
    static parser::Match Eq(TrivialLexer& lexer);
    static parser::Match YesNo(TrivialLexer& lexer);
};
